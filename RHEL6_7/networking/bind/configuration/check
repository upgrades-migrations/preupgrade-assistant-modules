#!/usr/bin/python
# -*- Mode: Python; python-indent: 8; indent-tabs-mode: t -*-
"""
"""

import sys
import os
import re
from preupg.script_api import *

from isccfg import ConfigParseError
import legacy

check_applies_to (check_applies="bind")
check_rpm_to (check_rpm="", check_bin="python")

#END GENERATED SECTION
# exit functions are exit_{pass,not_applicable, fixed, fail, etc.}
# logging functions are log_{error, warning, info, etc.}
# for logging in-place risk use functions log_{extreme, high, medium, slight}_risk

# Exit codes
EXIT_NOT_APPLICABLE = 0
EXIT_PASS = 1
EXIT_INFORMATIONAL = 2
EXIT_FIXED = 3
EXIT_FAIL = 4
EXIT_ERROR = 5


class SolutionText(object):
    """
    A class for handling the construction of the solution text
    """
    def __init__(self):
        self.header = """Some issues have been found in your BIND9 configuration.
Use the following solutions to fix them:"""
        self.tail = """For more information, see the BIND9 Administrator Reference
Manual located in the /usr/share/doc/bind-9.9.4/Bv9ARM.pdf file, and in the 'DNS Servers'
section of the Red Hat Enterprise Linux 7 Networking Guide."""
        self.solutions = []

    def add_solution(self, solution=""):
        if solution:
            self.solutions.append(solution)

    def get_text(self):
        text = self.header + "\n\n\n"
        for solution in self.solutions:
            text += solution + "\n\n\n"
        text += self.tail
        return text


# object used for creating solution text
sol_text = SolutionText()

def return_with_code(code):
    print("Exit code: ", code)
    return code


#######################################################
### CONFIGURATION CHECKS PART - BEGIN
#######################################################


CONFIG_CHECKS = []


def register_check(check):
    """
    Function decorator that adds configuration check into a list of checks.
    """
    CONFIG_CHECKS.append(check)
    return check


def run_checks(parser):
    """
    Runs all available checks on the files loaded into the files_to_check list.
    """
    gl_result = EXIT_PASS

    for check in CONFIG_CHECKS:
        log_info("Running check: \"" + check.__name__ + "\"")
        for cfg in parser.FILES_TO_CHECK:
            #log_info("checking: \"{path}\"".format(path=cfg.path))
            result = check(cfg.path, cfg.buffer)
            if result > gl_result:
                gl_result = result

    log_info("Running check: \"check_empty_zones_complex\"")
    result = check_empty_zones_complex(parser)
    if result > gl_result:
        gl_result = result

    log_info("Running check: \"check_default_runtime_dir\"")
    result = check_default_runtime_dir(parser)
    if result > gl_result:
        gl_result = result

    return gl_result


@register_check
def check_tcp_listen_queue(file_path, buff):
    """
    3581.	[bug]		Changed the tcp-listen-queue default to 10. [RT #33029]

    The default and minimum value changed from 3 to 10.

    From bind-9.9.4 ARM:
    The listen queue depth. The default and minimum is 10. If the kernel supports the
    accept filter 'dataready' this also controls how many TCP connections that will be queued in
    kernel space waiting for some data before being passed to accept. Nonzero values less than 10
    will be silently raised. A value of 0 may also be used; on most platforms this sets the listen queue
    length to a system-defined default value.
    """
    pattern = re.compile("tcp-listen-queue\s*([0-9]+)\s*;")
    match_iter = pattern.finditer(buff)
    status = EXIT_PASS

    for match in match_iter:
        try:
            number = int(match.group(1))
        except ValueError as e:
            raise(ConfigParseError("Value \"" + match.group(1) + "\" cannot be converted"), e)
            return EXIT_ERROR
        # the new default and minimum value is "10"
        if number > 0 and number < 10:
            log_slight_risk("Found \"" + match.group(0) + "\" in \"" +
                            file_path + "\"")
            sol_text.add_solution(
"""The tcp-listen-queue statement with a value less than 10:
The value specified in the tcp-listen-queue statement is less than 10.
Change your configuration to use at least the value of 10. BIND9
will silently ignore values less than 10, and use 10 instead.""")
            status = EXIT_INFORMATIONAL

    return status


@register_check
def check_zone_statistics(file_path, buff):
    """
    3501.	[func]   zone-statistics now takes three options: full,
                    terse, and none. "yes" and "no" are retained as
                    synonyms for "full" and "terse", respectively. [RT #29165]

    The options changed, but they are still compatible, and can be used in the new version.

    From bind-9.9.4 ARM:
    If full, the server will collect statistical data on all zones (unless specifically turned off
    on a per-zone basis by specifying zone-statistics terse or zone-statistics none in the zone state-
    ment). The default is terse, providing minimal statistics on zones (including name and current
    serial number, but not query type counters).

    For the compatibility with earlier versions of BIND9, the 'zone-statistics' option can also
    accept "yes" or "no", which have the same effect as "full" and "terse", respectively.
    """
    pattern = re.compile("zone-statistics\s*(yes|no)\s*;")
    match_iter = pattern.finditer(buff)
    status = EXIT_PASS

    for match in match_iter:
        log_slight_risk("Found \"" + match.group(0) + "\" in \"" +
                        file_path + "\"")
        sol_text.add_solution(
"""The 'zone-statistics' arguments changed:
Arguments of the 'zone-statistics' option changed in the new version of BIND9.
Replace the argument 'yes' with 'full', and replace the argument 'no' with 'terse'. The original options are still recognised by BIND9, and silently converted.""")
        status = EXIT_INFORMATIONAL

    return status


@register_check
def check_masterfile_format(file_path, buff):
    """
    3180.	[func]		Local copies of slave zones are now saved in a raw
                            format by default to improve the startup performance.
                            'masterfile-format text;' can be used to override
                            the default if desired. [RT #25867]

    The default format of the saved slave zone changed from 'text' to 'raw'.

    From bind-9.9.4 ARM:
    masterfile-format specifies the file format of zone files (see Section 6.3.7). The default value is text,
    which is a standard textual representation, except for slave zones, in which the default value
    is raw. Files in other formats than text are typically expected to be generated by the named-
    compilezone tool, or dumped by named.
    """
    pattern_zone_str = "zone\s+\"(.+?)\"(\s|.)*?{(\s|.)*?}"
    pattern_slave_str = "type\s+slave"
    pattern_mff_str = "masterfile-format"
    status = EXIT_PASS

    # find slave zones without masterfile-format statement
    pattern_zone = re.compile(pattern_zone_str)
    pattern_sl_zone = re.compile(pattern_slave_str)
    pattern_mff = re.compile(pattern_mff_str)
    pattern_zone_iter = pattern_zone.finditer(buff)

    for zone in pattern_zone_iter:
        slave_statement = pattern_sl_zone.search(zone.group(0))
        # if slave zone
        if slave_statement:
            mff_statement = pattern_mff.search(zone.group(0))
            # if no masterfile-format statement
            if not mff_statement:
                log_medium_risk("Found slave zone \"" + zone.group(1) + "\" in \"" +
                                file_path + "\" without \"masterfile-format\" statement.")
                status = EXIT_FAIL

    if status == EXIT_FAIL:
        sol_text.add_solution(
"""Slave zone definition without the 'masterfile-format' statement:
In the new version of BIND9, slave zones are saved by default as a 'raw'
format after the zone transfer. Previously, the default format was 'text'.
Use one of the following solutions:
- Remove saved slave zones files so that they are saved in the 'raw'
  format when transferred next time.
- Convert zones files to the 'raw' format by using the 'named-compilezone'
  tool.
- Include the 'masterfile-format text;' statement in the slave zone
  definition statement.""")

    return status


################################################################
# These checks can not be run as the rest, as they need to check
# all configuration files at once.

def check_empty_zones_complex(parser):
    """
    Check if there are any zones defined that are now included in empty zones.
    """
    status = EXIT_PASS

    new_ez = ["64.100.IN-ADDR.ARPA",
              "65.100.IN-ADDR.ARPA",
              "66.100.IN-ADDR.ARPA",
              "67.100.IN-ADDR.ARPA",
              "68.100.IN-ADDR.ARPA",
              "69.100.IN-ADDR.ARPA",
              "70.100.IN-ADDR.ARPA",
              "71.100.IN-ADDR.ARPA",
              "72.100.IN-ADDR.ARPA",
              "73.100.IN-ADDR.ARPA",
              "74.100.IN-ADDR.ARPA",
              "75.100.IN-ADDR.ARPA",
              "76.100.IN-ADDR.ARPA",
              "77.100.IN-ADDR.ARPA",
              "78.100.IN-ADDR.ARPA",
              "79.100.IN-ADDR.ARPA",
              "80.100.IN-ADDR.ARPA",
              "81.100.IN-ADDR.ARPA",
              "82.100.IN-ADDR.ARPA",
              "83.100.IN-ADDR.ARPA",
              "84.100.IN-ADDR.ARPA",
              "85.100.IN-ADDR.ARPA",
              "86.100.IN-ADDR.ARPA",
              "87.100.IN-ADDR.ARPA",
              "88.100.IN-ADDR.ARPA",
              "89.100.IN-ADDR.ARPA",
              "90.100.IN-ADDR.ARPA",
              "91.100.IN-ADDR.ARPA",
              "92.100.IN-ADDR.ARPA",
              "93.100.IN-ADDR.ARPA",
              "94.100.IN-ADDR.ARPA",
              "95.100.IN-ADDR.ARPA",
              "96.100.IN-ADDR.ARPA",
              "97.100.IN-ADDR.ARPA",
              "98.100.IN-ADDR.ARPA",
              "99.100.IN-ADDR.ARPA",
              "100.100.IN-ADDR.ARPA",
              "101.100.IN-ADDR.ARPA",
              "102.100.IN-ADDR.ARPA",
              "103.100.IN-ADDR.ARPA",
              "104.100.IN-ADDR.ARPA",
              "105.100.IN-ADDR.ARPA",
              "106.100.IN-ADDR.ARPA",
              "107.100.IN-ADDR.ARPA",
              "108.100.IN-ADDR.ARPA",
              "109.100.IN-ADDR.ARPA",
              "110.100.IN-ADDR.ARPA",
              "111.100.IN-ADDR.ARPA",
              "112.100.IN-ADDR.ARPA",
              "113.100.IN-ADDR.ARPA",
              "114.100.IN-ADDR.ARPA",
              "115.100.IN-ADDR.ARPA",
              "116.100.IN-ADDR.ARPA",
              "117.100.IN-ADDR.ARPA",
              "118.100.IN-ADDR.ARPA",
              "119.100.IN-ADDR.ARPA",
              "120.100.IN-ADDR.ARPA",
              "121.100.IN-ADDR.ARPA",
              "122.100.IN-ADDR.ARPA",
              "123.100.IN-ADDR.ARPA",
              "124.100.IN-ADDR.ARPA",
              "125.100.IN-ADDR.ARPA",
              "126.100.IN-ADDR.ARPA",
              "127.100.IN-ADDR.ARPA",
              ]

    # Create a global config
    configuration = ""
    for cfg in parser.FILES_TO_CHECK:
        configuration += cfg.buffer + "\n"

    ez_disable_pattern = re.compile("empty-zones-enable\s+no")
    # Check if empty zones are not disabled globally
    found = ez_disable_pattern.findall(configuration)
    if found:
        return status

    # Check new empty zones
    for empty_zone in new_ez:
        pattern = re.compile("zone\s+\"" + empty_zone + "\"", re.IGNORECASE)
        pattern_dis = re.compile(
            "disable-empty-zone\s+\"" + empty_zone + "\"", re.IGNORECASE)
        found = pattern.findall(configuration)
        if found:
            # check if the empty zone is not disabled individually
            found_dis = pattern_dis.findall(configuration)
            if found_dis:
                continue
            status = EXIT_FAIL
            log_high_risk("Found a zone \"" + empty_zone + "\" in BIND9 " +
                          "configuration. This zone will be overridden by a built-in " +
                          "empty zone if not disabled.")

    if status == EXIT_FAIL:
        sol_text.add_solution(
"""Zone declaration that conflicts with built-in empty zones:
In the new version of BIND9, the list of automatically created empty
zones expanded. Your configuration contains a zone that is conflicting
with a built-in empty zone. Use one of the following solutions:
- Disable the specific empty zone by using the 'disable-empty-zone <zone>;'
  statement.
- Disable empty zones globally by using the 'empty-zones-enable no;'
  statement.""")

    return status


def check_default_runtime_dir(parser):
    """
    Check if there are any statements needed for the /var/run -> /run move in 'options'.
    """
    status = EXIT_PASS
    FIX_STATEMENTS = [
        ("pid-file", '"/run/named/named.pid"'),
        ("session-keyfile", '"/run/named/session.key"'),
        ('dnssec-lookaside', 'no'),
    ]

    # find configuration file with the options section
    opt = None
    for cfg in parser.FILES_TO_CHECK:
        fpath = cfg.path
        opt_find = parser.find_val(cfg, "options")
        if opt_find != None:
            opt = opt_find
            log_info("Parsing file {path}, start {name} at {start}".format(path=fpath, name=opt.name, start=opt.start))
            for (key, val) in FIX_STATEMENTS:
                ret = parser.fix_statement(cfg, opt, key, val)
                if ret is False:
                    log_slight_risk("The \"%s\" statement cannot be fixed in the "
                                    "BIND9 configuration automatically." % key)
                    status = EXIT_FAIL
                    break
                else:
                    if cfg.status == EXIT_PASS:
                        log_info("The %s statement does not require change" % (key,))
                    else:
                        
                        log_info("The %s statement has been set to the expected value: %s"
                             % (key, val))
                    if status < EXIT_FIXED:
                        status = EXIT_FIXED

    if not opt:
        # unexpected error when BIND is used and works correctly
        raise(ConfigParseError("The options statement has not been found "
                               "or the configuration is broken."))

    if status == EXIT_PASS:
        return status

    sol_msg = (
"""New values of the 'pid-file' and the 'session-keyfile' statement:
The directory used by named for runtime data has been moved from the BIND
default location, which was the /var/run/named/ directory, to the /run/named/ directory.
As a result, the PID file has been moved from its default location
'/var/run/named/named.pid' to a new location '/run/named/named.pid'.
In addition, the session-key file has been moved to '/run/named/session.key'.
These locations need to be specified by statements in the options section.\n""")

    if status == EXIT_FAIL:
        sol_msg += ("To fix this, add the following statements into"
                    " the options section of your BIND9 configuration:")
    else:
        sol_msg += ("To fix this, the following statements have been set"
                    " (or added) inside the options section of your BIND9"
                    " configuration (modified files will be applied"
                    " automatically on the target system):")

    sol_msg += ("""
- 'pid-file  "/run/named/named.pid";'
- 'session-keyfile  "/run/named/session.key";'""")
    sol_text.add_solution("[FIXED] %s" % sol_msg)
    return status


def main():
    try:
        if len(sys.argv)>1:
            parser = legacy.BindLegacyParser(sys.argv[1])
        else:
            parser = legacy.BindLegacyParser()
        # need to check also paths of included files
        if not parser.is_config_changed():
            return_with_code(EXIT_PASS)
        result = run_checks(parser)
        # write the config into the respective dir
        # FIXME: this should copy original permissions from source file!
        parser.write_fixed_configs_to_disk(result, sol_text)
        # if there was some issue, write a solution text
        if result > EXIT_PASS:
            solution_file(sol_text.get_text())
            pass
        return_with_code(result)
    except ConfigParseError as e:
        print(e)
        return_with_code(EXIT_FAIL)

if __name__ == "__main__":
    main()
